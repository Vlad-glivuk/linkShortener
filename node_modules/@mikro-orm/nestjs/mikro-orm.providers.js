"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createMikroOrmRepositoryProviders = exports.createAsyncProviders = exports.createMikroOrmAsyncOptionsProvider = exports.createMikroOrmEntityManagerProvider = exports.createMikroOrmProvider = void 0;
const mikro_orm_common_1 = require("./mikro-orm.common");
const core_1 = require("@mikro-orm/core");
const common_1 = require("@nestjs/common");
const createMikroOrmProvider = () => ({
    provide: core_1.MikroORM,
    useFactory: async (options) => {
        if (options === null || options === void 0 ? void 0 : options.autoLoadEntities) {
            options.entities = [...(options.entities || []), ...mikro_orm_common_1.REGISTERED_ENTITIES.values()];
            options.entitiesTs = [...(options.entitiesTs || []), ...mikro_orm_common_1.REGISTERED_ENTITIES.values()];
            delete options.autoLoadEntities;
        }
        mikro_orm_common_1.REGISTERED_ENTITIES.clear();
        if (!options || Object.keys(options).length === 0) {
            const config = await core_1.ConfigurationLoader.getConfiguration();
            config.set('logger', mikro_orm_common_1.logger.log.bind(mikro_orm_common_1.logger));
            options = config;
        }
        return core_1.MikroORM.init(options);
    },
    inject: [mikro_orm_common_1.MIKRO_ORM_MODULE_OPTIONS],
});
exports.createMikroOrmProvider = createMikroOrmProvider;
const createMikroOrmEntityManagerProvider = (scope = common_1.Scope.DEFAULT, entityManager = core_1.EntityManager) => ({
    provide: entityManager,
    scope,
    useFactory: (orm) => scope === common_1.Scope.DEFAULT ? orm.em : orm.em.fork(),
    inject: [core_1.MikroORM],
});
exports.createMikroOrmEntityManagerProvider = createMikroOrmEntityManagerProvider;
const createMikroOrmAsyncOptionsProvider = (options) => {
    var _a;
    if (options.useFactory) {
        return {
            provide: mikro_orm_common_1.MIKRO_ORM_MODULE_OPTIONS,
            useFactory: options.useFactory,
            inject: options.inject || [],
        };
    }
    const inject = [];
    if (options.useClass || options.useExisting) {
        inject.push((_a = options.useClass) !== null && _a !== void 0 ? _a : options.useExisting);
    }
    return {
        provide: mikro_orm_common_1.MIKRO_ORM_MODULE_OPTIONS,
        useFactory: async (optionsFactory) => await optionsFactory.createMikroOrmOptions(),
        inject,
    };
};
exports.createMikroOrmAsyncOptionsProvider = createMikroOrmAsyncOptionsProvider;
const createAsyncProviders = (options) => {
    if (options.useExisting || options.useFactory) {
        return [exports.createMikroOrmAsyncOptionsProvider(options)];
    }
    if (options.useClass) {
        return [
            exports.createMikroOrmAsyncOptionsProvider(options),
            { provide: options.useClass, useClass: options.useClass },
        ];
    }
    throw new Error('Invalid MikroORM async options: one of `useClass`, `useExisting` or `useFactory` should be defined.');
};
exports.createAsyncProviders = createAsyncProviders;
const createMikroOrmRepositoryProviders = (entities) => {
    const metadata = Object.values(core_1.MetadataStorage.getMetadata());
    const providers = [];
    (entities || []).forEach(entity => {
        const meta = metadata.find(meta => meta.class === entity);
        if (meta === null || meta === void 0 ? void 0 : meta.customRepository) {
            providers.push({
                provide: meta.customRepository(),
                useFactory: em => em.getRepository(entity),
                inject: [core_1.EntityManager],
            });
        }
        providers.push({
            provide: mikro_orm_common_1.getRepositoryToken(entity),
            useFactory: em => em.getRepository(entity),
            inject: [core_1.EntityManager],
        });
    });
    return providers;
};
exports.createMikroOrmRepositoryProviders = createMikroOrmRepositoryProviders;
